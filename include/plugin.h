/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * The plugin data version
 * This is used in C interface. Rust users can ignore it
 */
#define DATA_VERSION 1

/**
 * utf8 null terminated string.
 *
 * # Safety
 * This points to a valid utf-8 string
 * Contains no internal nulls
 * Contains a null terminator
 */
typedef const char *RStr;

typedef struct Version {
  uint16_t major;
  uint16_t minor;
  uint16_t patch;
} Version;

/**
 * Plugin details; DATA_VERSION 1
 *
 * If you want to identify your own plugin,
 * export a symbol named PLUGIN_DATA containing
 * this data.
 */
typedef struct Plugin {
  /**
   * This MUST be set to `DATA_VERSION`
   */
  uintptr_t data_ver;
  RStr name;
  RStr author;
  RStr description;
  struct Version version;
} Plugin;

/**
 * Guard for the plugin data
 * `data` will be invalid when guard is freed
 */
typedef struct PluginGuard {
  const struct Plugin *data;
} PluginGuard;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get a plugin's data
 *
 * Takes in a path to the dll, encoded as UTF16, with length `len`
 * Returns null pointer if it failed, non-null if it succeeded.
 * If it failed, either the plugin didn't declare it, it's not a plugin made with Rust Native template,
 * or the file does not exist.
 *
 * # Safety
 * `len` must be the correct. this is the number of u16 elems, _not_ the number of bytes
 */
const struct PluginGuard *get_plugin_data(const uint16_t *dll,
                                          uintptr_t len);

/**
 * Free the memory used by PluginGuard
 *
 * # Safety
 * Must be pointer to a valid instance of PluginGuard
 */
void free_plugin(const struct PluginGuard *plugin);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
